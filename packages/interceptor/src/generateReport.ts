/**
 * Partially generated by AI
 */

import { CallStack, CallStackJson } from "../Interceptor.types";
import { writeFileSync } from "./envUtils";
import { getHtmlTemplate } from "./generateReport.template";
import { convertCallStackJsonToCallStack, validateStats } from "./validator";

type CallStackWithDuration = CallStack & {
    duration: number;
};

interface GenerateReportOptions {
    /**
     * Whether to include the request body in the report.
     * If a function is provided, it will be called with the URL of the request and should
     * return a boolean indicating whether the request body should be included.
     *
     * By default the request body is limited to 1000 characters. When provide `true`
     * the request body is included without any limit.
     *
     * If the request body is too big, it can affect the size of the report and the performance
     * of the report generation so you might need to increase the timeout in `writeOptions`.
     */
    includeRequestBody?: boolean | ((url: URL) => boolean);
    /**
     * Whether to include the response body in the report.
     * If a function is provided, it will be called with the URL of the request and should
     * return a boolean indicating whether the response body should be included.
     *
     * By default the response body is limited to 1000 characters. When provide `true`
     * the response body is included without any limit.
     *
     * If the request body is too big, it can affect the size of the report and the performance
     * of the report generation so you might need to increase the timeout in `writeOptions`.
     */
    includeResponseBody?: boolean | ((url: URL) => boolean);
    /**
     * The high duration for the report.
     * If a function is provided, it will be called with the URL of the request and should
     * return the high duration. If a number is provided, it will be used as the high duration
     * for all requests.
     */
    highDuration?: number | ((url: URL) => number);
    /**
     * A filter function that can be used to filter the data points before generating the report.
     * The function will be called with each data point and should return a boolean indicating whether
     * the data point should be included in the report.
     */
    filter?: (dataPoint: CallStack) => boolean;
    /**
     * The title of the report.
     */
    title?: string;
    /**
     * The options for `cy.writeFile`. Available only when calling `generateReport` from a
     * Cypress test.
     */
    writeOptions?: Partial<Cypress.WriteFileOptions & Cypress.Timeoutable>;
}

/**
 * Formats a Date object to "hours:minutes:seconds milliseconds" format
 */
const formatDateTime = (date: Date): string => {
    const hours = date.getHours().toString().padStart(2, "0");
    const minutes = date.getMinutes().toString().padStart(2, "0");
    const seconds = date.getSeconds().toString().padStart(2, "0");
    const milliseconds = date.getMilliseconds().toString().padStart(3, "0");

    return `${hours}:${minutes}:${seconds}s ${milliseconds}ms`;
};

/**
 * Helper to process request/response body according to includeBodyOption and limits
 */
const getProcessedBody = (
    body: string,
    urlString: string,
    includeBodyOption: boolean | ((url: URL) => boolean) | undefined,
    defaultLimit: number
): string | undefined => {
    if (!body) {
        return undefined;
    }

    // If option is true, return full body
    if (includeBodyOption === true) {
        return body;
    }

    // If option is a function, call it
    if (typeof includeBodyOption === "function") {
        let shouldIncludeFull = false;

        const url = new URL(urlString, "http://dummy");

        shouldIncludeFull = includeBodyOption(url);

        if (shouldIncludeFull) {
            return body;
        }

        if (body.length > defaultLimit) {
            return body.slice(0, defaultLimit) + "...";
        }

        return body;
    }

    // Default: limit to defaultLimit
    if (body.length > defaultLimit) {
        return body.slice(0, defaultLimit) + "...";
    }

    return body;
};

/**
 * Generates an HTML report with a column chart showing duration over time
 *
 * @param statsFilePath Path to the stats file. The file must be sorted by timeStart
 * and the function must be called from node (not from cypress)
 * @param outputFileName Path where the HTML file will be created
 * @param options Options
 */
export function generateReport(
    statsFilePath: string,
    outputFileName: string,
    options?: GenerateReportOptions
): void;
/**
 * Generates an HTML report with a column chart showing duration over time
 *
 * @param data The call stack data
 * @param filePath Path where the HTML file will be created
 * @param options Options
 */
export function generateReport(
    data: CallStack[],
    filePath: string,
    options?: GenerateReportOptions
): void;
export function generateReport(
    dataOrFilePath: CallStack[] | string,
    filePath: string,
    options: GenerateReportOptions = {}
): void {
    try {
        const { highDuration = 3000, filter } = options;

        let data = typeof dataOrFilePath === "string" ? loadStats(dataOrFilePath) : dataOrFilePath;

        if (filter) {
            data = data.filter(filter);
        }

        // filter out the ones with no duration
        const dataWithDuration: CallStackWithDuration[] = data.filter(
            (item): item is CallStackWithDuration => item.duration !== undefined
        );

        // Per-request highDuration logic
        const isCustomHighDuration = typeof highDuration === "function";
        const highDurations: number[] = dataWithDuration.map((item) => {
            if (isCustomHighDuration) {
                const url = new URL(item.url, "http://dummy");

                return highDuration(url);
            }

            return highDuration as number;
        });
        const isSlow: boolean[] = dataWithDuration.map(
            (item, i) => highDurations[i] > 0 && item.duration > highDurations[i]
        );

        // Prepare data for the chart
        const labels = dataWithDuration.map((item) => formatDateTime(item.timeStart));
        const durations = dataWithDuration.map((item) => item.duration);

        // Calculate statistics
        const maxDuration = durations.length > 0 ? Math.max(...durations) : 0;
        const minDuration = durations.length > 0 ? Math.min(...durations) : 0;
        const avgDuration =
            durations.length > 0
                ? durations.reduce((sum, duration) => sum + duration, 0) / durations.length
                : 0;

        // Generate HTML using the template function
        const html = getHtmlTemplate({
            avgDuration: avgDuration.toFixed(2),
            dataCount: dataWithDuration.length,
            durations: JSON.stringify(durations),
            generationDate: new Date().toLocaleString(),
            highDuration: isCustomHighDuration ? null : highDuration,
            highDurations: JSON.stringify(highDurations),
            isSlow: JSON.stringify(isSlow),
            isCustomHighDuration,
            labels: JSON.stringify(labels),
            maxDuration: maxDuration.toFixed(2),
            minDuration: minDuration.toFixed(2),
            tableData: JSON.stringify(
                dataWithDuration.map((item, i) => ({
                    duration: item.duration,
                    time: formatDateTime(item.timeStart),
                    url: item.url,
                    method: item.request.method,
                    query: item.request.query,
                    headers: item.request.headers,
                    requestBody: getProcessedBody(
                        item.request.body,
                        String(item.url),
                        options.includeRequestBody,
                        1000
                    ),
                    responseBody: getProcessedBody(
                        item.response?.body ?? "",
                        String(item.url),
                        options.includeResponseBody,
                        1000
                    ),
                    responseHeaders: item.response?.headers,
                    statusCode: item.response?.statusCode,
                    highDuration: highDurations[i],
                    isSlow: isSlow[i]
                }))
            ),
            title: options?.title,
            totalRequests: dataWithDuration.length
        });

        // Write the HTML file
        writeFileSync(filePath, html, options.writeOptions);

        console.info(`✅ Report generated successfully at: ${filePath}`);
    } catch (error) {
        console.error("❌ Error generating report:", error);
        throw error;
    }
}

const loadStats = (filePath: string): CallStack[] => {
    const requireFn = eval("require");
    const fs = requireFn("fs");

    const fileContent = fs.readFileSync(filePath, "utf8");
    const parsedData = JSON.parse(fileContent) as CallStackJson[];

    validateStats(parsedData);

    return convertCallStackJsonToCallStack(parsedData);
};
